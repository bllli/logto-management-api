// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/bllli/logto-management-api/internal/utils"
	"github.com/bllli/logto-management-api/models/components"
)

type TypesEnum2 string

const (
	TypesEnum2Native           TypesEnum2 = "Native"
	TypesEnum2Spa              TypesEnum2 = "SPA"
	TypesEnum2Traditional      TypesEnum2 = "Traditional"
	TypesEnum2MachineToMachine TypesEnum2 = "MachineToMachine"
	TypesEnum2Protected        TypesEnum2 = "Protected"
	TypesEnum2Saml             TypesEnum2 = "SAML"
)

func (e TypesEnum2) ToPointer() *TypesEnum2 {
	return &e
}
func (e *TypesEnum2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Native":
		fallthrough
	case "SPA":
		fallthrough
	case "Traditional":
		fallthrough
	case "MachineToMachine":
		fallthrough
	case "Protected":
		fallthrough
	case "SAML":
		*e = TypesEnum2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypesEnum2: %v", v)
	}
}

type TypesEnum1 string

const (
	TypesEnum1Native           TypesEnum1 = "Native"
	TypesEnum1Spa              TypesEnum1 = "SPA"
	TypesEnum1Traditional      TypesEnum1 = "Traditional"
	TypesEnum1MachineToMachine TypesEnum1 = "MachineToMachine"
	TypesEnum1Protected        TypesEnum1 = "Protected"
	TypesEnum1Saml             TypesEnum1 = "SAML"
)

func (e TypesEnum1) ToPointer() *TypesEnum1 {
	return &e
}
func (e *TypesEnum1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Native":
		fallthrough
	case "SPA":
		fallthrough
	case "Traditional":
		fallthrough
	case "MachineToMachine":
		fallthrough
	case "Protected":
		fallthrough
	case "SAML":
		*e = TypesEnum1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypesEnum1: %v", v)
	}
}

type TypesType string

const (
	TypesTypeArrayOfTypesEnum1 TypesType = "arrayOfTypesEnum1"
	TypesTypeTypesEnum2        TypesType = "types_enum_2"
)

// Types - An array of application types to filter applications.
type Types struct {
	ArrayOfTypesEnum1 []TypesEnum1 `queryParam:"inline"`
	TypesEnum2        *TypesEnum2  `queryParam:"inline"`

	Type TypesType
}

func CreateTypesArrayOfTypesEnum1(arrayOfTypesEnum1 []TypesEnum1) Types {
	typ := TypesTypeArrayOfTypesEnum1

	return Types{
		ArrayOfTypesEnum1: arrayOfTypesEnum1,
		Type:              typ,
	}
}

func CreateTypesTypesEnum2(typesEnum2 TypesEnum2) Types {
	typ := TypesTypeTypesEnum2

	return Types{
		TypesEnum2: &typesEnum2,
		Type:       typ,
	}
}

func (u *Types) UnmarshalJSON(data []byte) error {

	var arrayOfTypesEnum1 []TypesEnum1 = []TypesEnum1{}
	if err := utils.UnmarshalJSON(data, &arrayOfTypesEnum1, "", true, true); err == nil {
		u.ArrayOfTypesEnum1 = arrayOfTypesEnum1
		u.Type = TypesTypeArrayOfTypesEnum1
		return nil
	}

	var typesEnum2 TypesEnum2 = TypesEnum2("")
	if err := utils.UnmarshalJSON(data, &typesEnum2, "", true, true); err == nil {
		u.TypesEnum2 = &typesEnum2
		u.Type = TypesTypeTypesEnum2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Types", string(data))
}

func (u Types) MarshalJSON() ([]byte, error) {
	if u.ArrayOfTypesEnum1 != nil {
		return utils.MarshalJSON(u.ArrayOfTypesEnum1, "", true)
	}

	if u.TypesEnum2 != nil {
		return utils.MarshalJSON(u.TypesEnum2, "", true)
	}

	return nil, errors.New("could not marshal union type Types: all fields are null")
}

type ListApplicationsRequest struct {
	// An array of application types to filter applications.
	Types                 *Types  `queryParam:"style=form,explode=true,name=types"`
	ExcludeRoleID         *string `queryParam:"style=form,explode=true,name=excludeRoleId"`
	ExcludeOrganizationID *string `queryParam:"style=form,explode=true,name=excludeOrganizationId"`
	IsThirdParty          *string `queryParam:"style=form,explode=true,name=isThirdParty"`
	// Page number (starts from 1).
	Page *int64 `default:"1" queryParam:"style=form,explode=true,name=page"`
	// Entries per page.
	PageSize *int64 `default:"20" queryParam:"style=form,explode=true,name=page_size"`
	// Search query parameters.
	SearchParams map[string]string `queryParam:"style=form,explode=true,name=search_params"`
}

func (l ListApplicationsRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListApplicationsRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ListApplicationsRequest) GetTypes() *Types {
	if o == nil {
		return nil
	}
	return o.Types
}

func (o *ListApplicationsRequest) GetExcludeRoleID() *string {
	if o == nil {
		return nil
	}
	return o.ExcludeRoleID
}

func (o *ListApplicationsRequest) GetExcludeOrganizationID() *string {
	if o == nil {
		return nil
	}
	return o.ExcludeOrganizationID
}

func (o *ListApplicationsRequest) GetIsThirdParty() *string {
	if o == nil {
		return nil
	}
	return o.IsThirdParty
}

func (o *ListApplicationsRequest) GetPage() *int64 {
	if o == nil {
		return nil
	}
	return o.Page
}

func (o *ListApplicationsRequest) GetPageSize() *int64 {
	if o == nil {
		return nil
	}
	return o.PageSize
}

func (o *ListApplicationsRequest) GetSearchParams() map[string]string {
	if o == nil {
		return nil
	}
	return o.SearchParams
}

type ListApplicationsType string

const (
	ListApplicationsTypeNative           ListApplicationsType = "Native"
	ListApplicationsTypeSpa              ListApplicationsType = "SPA"
	ListApplicationsTypeTraditional      ListApplicationsType = "Traditional"
	ListApplicationsTypeMachineToMachine ListApplicationsType = "MachineToMachine"
	ListApplicationsTypeProtected        ListApplicationsType = "Protected"
	ListApplicationsTypeSaml             ListApplicationsType = "SAML"
)

func (e ListApplicationsType) ToPointer() *ListApplicationsType {
	return &e
}
func (e *ListApplicationsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Native":
		fallthrough
	case "SPA":
		fallthrough
	case "Traditional":
		fallthrough
	case "MachineToMachine":
		fallthrough
	case "Protected":
		fallthrough
	case "SAML":
		*e = ListApplicationsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListApplicationsType: %v", v)
	}
}

// ListApplicationsRedirectUris2 - Validator function
type ListApplicationsRedirectUris2 struct {
}

// ListApplicationsRedirectUris1 - Validator function
type ListApplicationsRedirectUris1 struct {
}

type ListApplicationsRedirectUrisUnionType string

const (
	ListApplicationsRedirectUrisUnionTypeListApplicationsRedirectUris1 ListApplicationsRedirectUrisUnionType = "ListApplications_redirectUris_1"
	ListApplicationsRedirectUrisUnionTypeListApplicationsRedirectUris2 ListApplicationsRedirectUrisUnionType = "ListApplications_redirectUris_2"
)

type ListApplicationsRedirectUrisUnion struct {
	ListApplicationsRedirectUris1 *ListApplicationsRedirectUris1 `queryParam:"inline"`
	ListApplicationsRedirectUris2 *ListApplicationsRedirectUris2 `queryParam:"inline"`

	Type ListApplicationsRedirectUrisUnionType
}

func CreateListApplicationsRedirectUrisUnionListApplicationsRedirectUris1(listApplicationsRedirectUris1 ListApplicationsRedirectUris1) ListApplicationsRedirectUrisUnion {
	typ := ListApplicationsRedirectUrisUnionTypeListApplicationsRedirectUris1

	return ListApplicationsRedirectUrisUnion{
		ListApplicationsRedirectUris1: &listApplicationsRedirectUris1,
		Type:                          typ,
	}
}

func CreateListApplicationsRedirectUrisUnionListApplicationsRedirectUris2(listApplicationsRedirectUris2 ListApplicationsRedirectUris2) ListApplicationsRedirectUrisUnion {
	typ := ListApplicationsRedirectUrisUnionTypeListApplicationsRedirectUris2

	return ListApplicationsRedirectUrisUnion{
		ListApplicationsRedirectUris2: &listApplicationsRedirectUris2,
		Type:                          typ,
	}
}

func (u *ListApplicationsRedirectUrisUnion) UnmarshalJSON(data []byte) error {

	var listApplicationsRedirectUris1 ListApplicationsRedirectUris1 = ListApplicationsRedirectUris1{}
	if err := utils.UnmarshalJSON(data, &listApplicationsRedirectUris1, "", true, true); err == nil {
		u.ListApplicationsRedirectUris1 = &listApplicationsRedirectUris1
		u.Type = ListApplicationsRedirectUrisUnionTypeListApplicationsRedirectUris1
		return nil
	}

	var listApplicationsRedirectUris2 ListApplicationsRedirectUris2 = ListApplicationsRedirectUris2{}
	if err := utils.UnmarshalJSON(data, &listApplicationsRedirectUris2, "", true, true); err == nil {
		u.ListApplicationsRedirectUris2 = &listApplicationsRedirectUris2
		u.Type = ListApplicationsRedirectUrisUnionTypeListApplicationsRedirectUris2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ListApplicationsRedirectUrisUnion", string(data))
}

func (u ListApplicationsRedirectUrisUnion) MarshalJSON() ([]byte, error) {
	if u.ListApplicationsRedirectUris1 != nil {
		return utils.MarshalJSON(u.ListApplicationsRedirectUris1, "", true)
	}

	if u.ListApplicationsRedirectUris2 != nil {
		return utils.MarshalJSON(u.ListApplicationsRedirectUris2, "", true)
	}

	return nil, errors.New("could not marshal union type ListApplicationsRedirectUrisUnion: all fields are null")
}

type ListApplicationsOidcClientMetadata struct {
	RedirectUris                     []ListApplicationsRedirectUrisUnion `json:"redirectUris"`
	PostLogoutRedirectUris           []string                            `json:"postLogoutRedirectUris"`
	BackchannelLogoutURI             *string                             `json:"backchannelLogoutUri,omitempty"`
	BackchannelLogoutSessionRequired *bool                               `json:"backchannelLogoutSessionRequired,omitempty"`
	LogoURI                          *string                             `json:"logoUri,omitempty"`
}

func (o *ListApplicationsOidcClientMetadata) GetRedirectUris() []ListApplicationsRedirectUrisUnion {
	if o == nil {
		return []ListApplicationsRedirectUrisUnion{}
	}
	return o.RedirectUris
}

func (o *ListApplicationsOidcClientMetadata) GetPostLogoutRedirectUris() []string {
	if o == nil {
		return []string{}
	}
	return o.PostLogoutRedirectUris
}

func (o *ListApplicationsOidcClientMetadata) GetBackchannelLogoutURI() *string {
	if o == nil {
		return nil
	}
	return o.BackchannelLogoutURI
}

func (o *ListApplicationsOidcClientMetadata) GetBackchannelLogoutSessionRequired() *bool {
	if o == nil {
		return nil
	}
	return o.BackchannelLogoutSessionRequired
}

func (o *ListApplicationsOidcClientMetadata) GetLogoURI() *string {
	if o == nil {
		return nil
	}
	return o.LogoURI
}

type ListApplicationsCustomClientMetadata struct {
	CorsAllowedOrigins      []string `json:"corsAllowedOrigins,omitempty"`
	IDTokenTTL              *float64 `json:"idTokenTtl,omitempty"`
	RefreshTokenTTL         *float64 `json:"refreshTokenTtl,omitempty"`
	RefreshTokenTTLInDays   *float64 `json:"refreshTokenTtlInDays,omitempty"`
	TenantID                *string  `json:"tenantId,omitempty"`
	AlwaysIssueRefreshToken *bool    `json:"alwaysIssueRefreshToken,omitempty"`
	RotateRefreshToken      *bool    `json:"rotateRefreshToken,omitempty"`
}

func (o *ListApplicationsCustomClientMetadata) GetCorsAllowedOrigins() []string {
	if o == nil {
		return nil
	}
	return o.CorsAllowedOrigins
}

func (o *ListApplicationsCustomClientMetadata) GetIDTokenTTL() *float64 {
	if o == nil {
		return nil
	}
	return o.IDTokenTTL
}

func (o *ListApplicationsCustomClientMetadata) GetRefreshTokenTTL() *float64 {
	if o == nil {
		return nil
	}
	return o.RefreshTokenTTL
}

func (o *ListApplicationsCustomClientMetadata) GetRefreshTokenTTLInDays() *float64 {
	if o == nil {
		return nil
	}
	return o.RefreshTokenTTLInDays
}

func (o *ListApplicationsCustomClientMetadata) GetTenantID() *string {
	if o == nil {
		return nil
	}
	return o.TenantID
}

func (o *ListApplicationsCustomClientMetadata) GetAlwaysIssueRefreshToken() *bool {
	if o == nil {
		return nil
	}
	return o.AlwaysIssueRefreshToken
}

func (o *ListApplicationsCustomClientMetadata) GetRotateRefreshToken() *bool {
	if o == nil {
		return nil
	}
	return o.RotateRefreshToken
}

type ListApplicationsPageRule struct {
	Path string `json:"path"`
}

func (o *ListApplicationsPageRule) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

type ListApplicationsStatus string

const (
	ListApplicationsStatusPendingVerification ListApplicationsStatus = "PendingVerification"
	ListApplicationsStatusPendingSsl          ListApplicationsStatus = "PendingSsl"
	ListApplicationsStatusActive              ListApplicationsStatus = "Active"
	ListApplicationsStatusError               ListApplicationsStatus = "Error"
)

func (e ListApplicationsStatus) ToPointer() *ListApplicationsStatus {
	return &e
}
func (e *ListApplicationsStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "PendingVerification":
		fallthrough
	case "PendingSsl":
		fallthrough
	case "Active":
		fallthrough
	case "Error":
		*e = ListApplicationsStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListApplicationsStatus: %v", v)
	}
}

type ListApplicationsDNSRecord struct {
	Name  string `json:"name"`
	Type  string `json:"type"`
	Value string `json:"value"`
}

func (o *ListApplicationsDNSRecord) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ListApplicationsDNSRecord) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *ListApplicationsDNSRecord) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type ListApplicationsValidationError struct {
	Message string `json:"message"`
}

func (o *ListApplicationsValidationError) GetMessage() string {
	if o == nil {
		return ""
	}
	return o.Message
}

type ListApplicationsSsl struct {
	Status           string                            `json:"status"`
	ValidationErrors []ListApplicationsValidationError `json:"validation_errors,omitempty"`
}

func (o *ListApplicationsSsl) GetStatus() string {
	if o == nil {
		return ""
	}
	return o.Status
}

func (o *ListApplicationsSsl) GetValidationErrors() []ListApplicationsValidationError {
	if o == nil {
		return nil
	}
	return o.ValidationErrors
}

type ListApplicationsCloudflareData struct {
	ID                 string              `json:"id"`
	Status             string              `json:"status"`
	Ssl                ListApplicationsSsl `json:"ssl"`
	VerificationErrors []string            `json:"verification_errors,omitempty"`
}

func (o *ListApplicationsCloudflareData) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ListApplicationsCloudflareData) GetStatus() string {
	if o == nil {
		return ""
	}
	return o.Status
}

func (o *ListApplicationsCloudflareData) GetSsl() ListApplicationsSsl {
	if o == nil {
		return ListApplicationsSsl{}
	}
	return o.Ssl
}

func (o *ListApplicationsCloudflareData) GetVerificationErrors() []string {
	if o == nil {
		return nil
	}
	return o.VerificationErrors
}

type ListApplicationsCustomDomain struct {
	Domain         string                          `json:"domain"`
	Status         ListApplicationsStatus          `json:"status"`
	ErrorMessage   *string                         `json:"errorMessage"`
	DNSRecords     []ListApplicationsDNSRecord     `json:"dnsRecords"`
	CloudflareData *ListApplicationsCloudflareData `json:"cloudflareData"`
}

func (o *ListApplicationsCustomDomain) GetDomain() string {
	if o == nil {
		return ""
	}
	return o.Domain
}

func (o *ListApplicationsCustomDomain) GetStatus() ListApplicationsStatus {
	if o == nil {
		return ListApplicationsStatus("")
	}
	return o.Status
}

func (o *ListApplicationsCustomDomain) GetErrorMessage() *string {
	if o == nil {
		return nil
	}
	return o.ErrorMessage
}

func (o *ListApplicationsCustomDomain) GetDNSRecords() []ListApplicationsDNSRecord {
	if o == nil {
		return []ListApplicationsDNSRecord{}
	}
	return o.DNSRecords
}

func (o *ListApplicationsCustomDomain) GetCloudflareData() *ListApplicationsCloudflareData {
	if o == nil {
		return nil
	}
	return o.CloudflareData
}

type ListApplicationsProtectedAppMetadata struct {
	Host            string                         `json:"host"`
	Origin          string                         `json:"origin"`
	SessionDuration float64                        `json:"sessionDuration"`
	PageRules       []ListApplicationsPageRule     `json:"pageRules"`
	CustomDomains   []ListApplicationsCustomDomain `json:"customDomains,omitempty"`
}

func (o *ListApplicationsProtectedAppMetadata) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *ListApplicationsProtectedAppMetadata) GetOrigin() string {
	if o == nil {
		return ""
	}
	return o.Origin
}

func (o *ListApplicationsProtectedAppMetadata) GetSessionDuration() float64 {
	if o == nil {
		return 0.0
	}
	return o.SessionDuration
}

func (o *ListApplicationsProtectedAppMetadata) GetPageRules() []ListApplicationsPageRule {
	if o == nil {
		return []ListApplicationsPageRule{}
	}
	return o.PageRules
}

func (o *ListApplicationsProtectedAppMetadata) GetCustomDomains() []ListApplicationsCustomDomain {
	if o == nil {
		return nil
	}
	return o.CustomDomains
}

// ListApplicationsCustomData - arbitrary
type ListApplicationsCustomData struct {
}

type ListApplicationsResponseBody struct {
	TenantID string `json:"tenantId"`
	ID       string `json:"id"`
	Name     string `json:"name"`
	// The internal client secret. Note it is only used for internal validation, and the actual secrets should be retrieved from `/api/applications/{id}/secrets` endpoints.
	//
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	Secret               string                                `json:"secret"`
	Description          *string                               `json:"description"`
	Type                 ListApplicationsType                  `json:"type"`
	OidcClientMetadata   ListApplicationsOidcClientMetadata    `json:"oidcClientMetadata"`
	CustomClientMetadata ListApplicationsCustomClientMetadata  `json:"customClientMetadata"`
	ProtectedAppMetadata *ListApplicationsProtectedAppMetadata `json:"protectedAppMetadata"`
	// arbitrary
	CustomData   ListApplicationsCustomData `json:"customData"`
	IsThirdParty bool                       `json:"isThirdParty"`
	CreatedAt    float64                    `json:"createdAt"`
}

func (o *ListApplicationsResponseBody) GetTenantID() string {
	if o == nil {
		return ""
	}
	return o.TenantID
}

func (o *ListApplicationsResponseBody) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ListApplicationsResponseBody) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ListApplicationsResponseBody) GetSecret() string {
	if o == nil {
		return ""
	}
	return o.Secret
}

func (o *ListApplicationsResponseBody) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *ListApplicationsResponseBody) GetType() ListApplicationsType {
	if o == nil {
		return ListApplicationsType("")
	}
	return o.Type
}

func (o *ListApplicationsResponseBody) GetOidcClientMetadata() ListApplicationsOidcClientMetadata {
	if o == nil {
		return ListApplicationsOidcClientMetadata{}
	}
	return o.OidcClientMetadata
}

func (o *ListApplicationsResponseBody) GetCustomClientMetadata() ListApplicationsCustomClientMetadata {
	if o == nil {
		return ListApplicationsCustomClientMetadata{}
	}
	return o.CustomClientMetadata
}

func (o *ListApplicationsResponseBody) GetProtectedAppMetadata() *ListApplicationsProtectedAppMetadata {
	if o == nil {
		return nil
	}
	return o.ProtectedAppMetadata
}

func (o *ListApplicationsResponseBody) GetCustomData() ListApplicationsCustomData {
	if o == nil {
		return ListApplicationsCustomData{}
	}
	return o.CustomData
}

func (o *ListApplicationsResponseBody) GetIsThirdParty() bool {
	if o == nil {
		return false
	}
	return o.IsThirdParty
}

func (o *ListApplicationsResponseBody) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

type ListApplicationsResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// A list of applications.
	ResponseBodies []ListApplicationsResponseBody
}

func (o *ListApplicationsResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *ListApplicationsResponse) GetResponseBodies() []ListApplicationsResponseBody {
	if o == nil {
		return nil
	}
	return o.ResponseBodies
}
